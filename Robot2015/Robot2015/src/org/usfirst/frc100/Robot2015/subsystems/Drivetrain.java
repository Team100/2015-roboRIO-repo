package org.usfirst.frc100.Robot2015.subsystems;

import org.usfirst.frc100.Robot2015.PID;
import org.usfirst.frc100.Robot2015.RobotMap;
import org.usfirst.frc100.Robot2015.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CounterBase.EncodingType; import edu.wpi.first.wpilibj.PIDSource.PIDSourceParameter;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The "butterslide" drivetrain of the robot.
 */
public class Drivetrain extends Subsystem {
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController leftMotor = RobotMap.drivetrainLeftMotor;
    SpeedController rightMotor = RobotMap.drivetrainRightMotor;
    RobotDrive robotDrive = RobotMap.drivetrainRobotDrive;
    SpeedController slideMotor = RobotMap.drivetrainSlideMotor;
    DoubleSolenoid leftShifter = RobotMap.drivetrainLeftShifter;
    DoubleSolenoid rightShifter = RobotMap.drivetrainRightShifter;
    DoubleSolenoid butterflyPiston = RobotMap.drivetrainButterflyPiston;
    Encoder leftEncoder = RobotMap.drivetrainLeftEncoder;
    Encoder rightEncoder = RobotMap.drivetrainRightEncoder;
    Encoder slideEncoder = RobotMap.drivetrainSlideEncoder;
    Gyro gyro = RobotMap.drivetrainGyro;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private double velocity = 0;
    private double previousVelocity = 0;
    private double accelerationLimit = 0;
    private double accelerationLoopInterval = 20;
    private Timer timer = new Timer();
    PID distancePID = new PID("DriveDistance");
    PID anglePID = new PID("DriveAngle");
    PID slidePID = new PID("DriveSlide");

    // Sets the default command to Drive
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }
    
    // Drives the robot using the given the speed, strafe, and turn values
    public void drive(double speed, double strafe, double turn) {
    	robotDrive.arcadeDrive(speed, turn);
    	slideMotor.set(strafe);
    }
    
    // Shifts to high or low gear
    public void shift(boolean highgear) {
    	if(highgear) {
    		leftShifter.set(DoubleSolenoid.Value.kForward);
    		rightShifter.set(DoubleSolenoid.Value.kForward);
    	} 
    	else {
    		leftShifter.set(DoubleSolenoid.Value.kReverse);
        	rightShifter.set(DoubleSolenoid.Value.kReverse);
    	}
    }
    
    // Switches to tank or slide drive
    public void switchDrive(boolean tankdrive) {
    	if(tankdrive) {
    		butterflyPiston.set(DoubleSolenoid.Value.kReverse);
    	}
    	else{
    		butterflyPiston.set(DoubleSolenoid.Value.kForward);
    	}	
     }
    
    // Returns whether the drivetrain is in slide mode
    public boolean isSlide() {
    	if(butterflyPiston.get() == DoubleSolenoid.Value.kForward){
    		return true;
    	}
    	else {
    		return false;
    	}
    }
    
    // Limits the acceleration.
    public void gradualDrive(double yaxis, double slide, double turn) {
        timer.stop();
        accelerationLoopInterval = timer.get();
        velocity = leftEncoder.getRate();
        if ((velocity - previousVelocity) / accelerationLoopInterval > SmartDashboard.getNumber("Uppper Acceleration Limit", 100000000)) {
             drive(accelerationLimit, slide, turn);

        } else if ((velocity - previousVelocity) / accelerationLoopInterval < SmartDashboard.getNumber("Lower  Acceleration Limit", -100000000)) {
            drive(accelerationLimit, slide, turn);

        } else {
            if(yaxis > accelerationLimit) {
                accelerationLimit += SmartDashboard.getNumber("Limit Step");
            } else{
               accelerationLimit -= SmartDashboard.getNumber("Limit Step");
            }
            drive(accelerationLimit, slide, turn);
        }
        previousVelocity = velocity;
        timer.start();
    }
    
    // Sets the target for the auto PID
    public void setAutoTarget(double targetDistance, double targetSlide, double targetAngle ){
    	distancePID.setTarget(targetDistance);
    	slidePID.setTarget(targetSlide);
    	anglePID.setTarget(targetAngle);
    	distancePID.reset();
    	slidePID.reset();
    	anglePID.reset();
    }
    
    // Updates the auto PID
    public void updateAuto() {
    	distancePID.update((leftEncoder.getDistance() + rightEncoder.getDistance()) /2);
    	slidePID.update(slideEncoder.getDistance());
    	anglePID.update(gyro.getAngle());
    	drive(distancePID.getOutput(), slidePID.getOutput(), anglePID.getOutput());
    }
    
    // Returns whether the auto PID has finished
    public boolean autoReachedTarget(){
    	return distancePID.reachedTarget() && anglePID.reachedTarget() && slidePID.reachedTarget();
    }
    
    // Updates the SmartDashboard
    public void updateDashboard() {
    	SmartDashboard.putNumber("DriveTrain Acceleration Limit", accelerationLimit);
        SmartDashboard.putNumber("DriveTrain Interval", accelerationLoopInterval);
        SmartDashboard.putNumber("DriveTrain Velocity", velocity); // only applies to non-slide
        SmartDashboard.putNumber("DriveTrain Acceleration", (velocity - previousVelocity) / accelerationLoopInterval );
        SmartDashboard.putBoolean("DriveTrain High Gear", leftShifter.get() == DoubleSolenoid.Value.kForward);
        SmartDashboard.putBoolean("DriveTrain Slide Mode", isSlide());
    }
}
