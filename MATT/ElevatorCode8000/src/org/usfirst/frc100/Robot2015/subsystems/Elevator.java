package org.usfirst.frc100.Robot2015.subsystems;

import org.usfirst.frc100.Robot2015.PID;
import org.usfirst.frc100.Robot2015.Robot;
import org.usfirst.frc100.Robot2015.RobotMap;
import org.usfirst.frc100.Robot2015.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.PIDSource.PIDSourceParameter;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * The elevator that raises and lowers game pieces. Uses a brake to hold at
 * constant position.
 */
public class Elevator extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController motor = RobotMap.elevatorMotor;
    Encoder encoder = RobotMap.elevatorEncoder;
    DoubleSolenoid brake = RobotMap.elevatorBrake;
    DigitalInput upperLimit = RobotMap.elevatorUpperLimit;
    DigitalInput lowerLimit = RobotMap.elevatorLowerLimit;
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    PID elevatorPID = new PID("elevator");
    boolean teleportSuccessful = false;
    final double positionOne = 6; //inches
    final double toteHeight = 11.75; //inches, compensated for 0.35 difference between lip and actual
    final double driveDiffHeight = 1.0; //inches
    final double scoringPlatformHeight = 2.0; //inches
    final double stepHeight = 4.0; //inches, compensated for the standard +2in for scoring
    
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
    	}

    
    //activates the brake
    public void makeItStop()
    {
    	motor.set(0);
    	brake.set(DoubleSolenoid.Value.kReverse);
    }
    //deactivates the brake
    public void letItGo()
    {
    	brake.set(DoubleSolenoid.Value.kForward);
    }
    
    
    //getter method for lower limit
    public boolean rockBottomLobster()
    {
    	return lowerLimit.get();
    }
    
    //setter method for elevatorPID zeroing
    public void zeroPID()
    {
    	elevatorPID.setRelativeLocation(0);
    }
    
    //sets the motor speeds according to the PID output
    public void updatePID()
    {
    	elevatorPID.update(encoder.getDistance());
    	if(Math.abs(elevatorPID.getError()) > 1.5) { //1.5 inch tolerance 
    		weHaveFullPower(elevatorPID.getOutput());
    	}
    	else {
    		makeItStop();
    		teleportSuccessful = true; 
    	}
    }
    
    //moves the elevator to the position defined in the parameter shadows
    public void blink(int shadows)
    {
    	double height = positionOne;
    	if(Robot.drivetrain.isSlide()){
    		height+=driveDiffHeight;
    	}
    	height += (shadows - 1)*toteHeight;
    	if(!Robot.oi.notScoringButton.get())
    	{
    		height += scoringPlatformHeight;
    	}
    	if(Robot.oi.coopertitionButton.get()){
    		height+= stepHeight; 
    	}
    	elevatorPID.setTarget(height);
    	teleportSuccessful = false;
    }
     //returns if PID target has been reached 
    public boolean getWarpStatus()
    {
    	return teleportSuccessful;
    }
    
    
    //for manual control
    public void weHaveFullPower(double energy)
    {
    	if(!upperLimit.get() && !lowerLimit.get())
    	{
    		letItGo();
    		motor.set(energy);
    	}
    	else if(upperLimit.get())
    	{
    		if(energy <0)
    		{
    			letItGo();
    			motor.set(energy);
    		}
    		else
    		{
    			makeItStop();
    		}
    	}
    	else if(lowerLimit.get())
    	{
    		elevatorPID.setRelativeLocation(0);
    		if(energy >0)
    		{
    			letItGo();
    			motor.set(energy);
    		}
    		else
    		{
    			makeItStop();
    		}
    	}
    }
    
    
    
    
    
    
    
}
